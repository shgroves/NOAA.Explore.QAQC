---
title: "preprocessing"
output: html_document
date: "2024-09-20"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(dplyr)
library(ggplot2)
library(tidyverse)
library(sf)
```

# Subset dataset

```{r}
setwd("~/NOAA/NOAA.Explore.QAQC/R")
expedition = "EX2306_Survey_Data_20240528.csv"
survey_df = read.csv(paste0("../../data/",expedition))
# paste0: doesn't add seperators btw items else paste defaults to singel space
# paste: can add optional delimiteers (sep = "_")
```

```{r}
# Column Options

col = "SampleID"
# col = "TrackingID"
# col = "Citation"
# col = "Repository"
# col = "ScientificName"
# col = "VernacularNameCategory"
# col = "VernacularName"
# col = "TaxonRank"
# col = "AphiaID"
# col = "LifeScienceIdentifier"
# col = "Phylum"
# col = "Class"
# col = "Subclass"
# col = "Order"
# col = "Suborder"
# col = "Family"
# col = "Subfamily"
# col = "Genus"
# col = "Subgenus"
# col = "Species"
# col = "Subspecies"
# col = "ScientificNameAuthorship"
# col = "Morphospecies"
# col = "CombinedNameID"
# col = "Synonyms"
# col = "IdentificationComments"
# col = "IdentifiedBy"
# col = "IdentificationDate"
# col = "IdentificationQualifier"
# col = "IdentificationVerificationStatus"
# col = "Ocean"
# col = "LargeMarineEcosystem"
# col = "Country"
# col = "FishCouncilRegion"
# col = "Locality"
# col = "Latitude"
# col = "Longitude"
# col = "DepthInMeters"
# col = "DepthMethod"
# col = "MinimumDepthInMeters"
# col = "MaximumDepthInMeters"
# col = "LocationComments"
# col = "ObservationDate"
# col = "ObservationTime"
# col = "SurveyID"
# col = "Vessel"
# col = "PI"
# col = "PIAffiliation"
# col = "Purpose"
# col = "SurveyComments"
# col = "Station"
# col = "EventID"
# col = "SamplingEquipment"
# col = "VehicleName"
# col = "SampleAreaInSquareMeters"
# col = "footprintWKT"
# col = "footprintSRS"
# col = "IndividualCount"
# col = "CategoricalAbundance"
# col = "Density"
# col = "Cover"
# col = "VerbatimSize"
# col = "MinimumSize"
# col = "MaximumSize"
# col = "WeightInKg"
# col = "Condition"
# col = "AssociatedTaxa"
# col = "OccurrenceComments"
# col = "LocationAccuracy"
# col = "NavType"
# col = "OtherData"
# col = "Habitat"
# col = "Substrate"
# col = "CMECSGeoForm"
# col = "Temperature"
# col = "Salinity"
# col = "Oxygen"
# col = "RecordType"
# col = "ImageFilePath"
# col = "HighlightImageFilePath"
# col = "DataProvider"
# col = "DataContact"
# col = "Modified"
# col = "WebSite"
# col = "EntryDate"
# col = "Reporter"
# col = "ReporterEmail"
# col = "ReporterComments"
# col = "VideoURI"
```

```{r}
### Data Cleaning ###
# filter function for missing / unexpected values


filter_df <- function(df, col = NA, filter_type = "missing", return_type = "original", num_missing = 0, unexpected_value = -999, lat_long = NA) {
  # filter_type: 
  #   -  "missing" : filter na values
  #   - "unexpected" : filter value stored in unexpected_value
  # return_type: 
  #   -  original: return the original df filtered for specified values
  #   -  filtered: return the rows that contain specified / missing value
  # num_missing:
  #   - threshold for missing values, return subset if >  num_missing
  # unexpected_value
  #   - value to filter unexpected by
  
  if (filter_type == "missing"){
    subset_rows = is.na(df[[col]])
    if (length(subset_rows) > num_missing) {
      print(paste(length(subset_rows), "missing values in", col))
    } else {
      print(paste(nrow(filtered), "missing values in", col))
    }
  } else if (filter_type == "unexpected") {
    subset_rows = df[[col]] == unexpected_value
    num_unexp = length(subset_rows)
    print(paste(num_unexp, "unexpected values in", col))
  } else if (is.na(col) & !is.na(lat_long)){
    # subset_rows = df %>%
    #   filter(between(Latitude, lat_long[[1]][1], lat_long[[1]][2]) &
    #          between(Longitude, lat_long[[2]][1], lat_long[[2]][2]))
    subset_rows <- df %>%
      mutate(in_range = between(Latitude, lat_long[[1]][1], lat_long[[1]][2]) &
                         between(Longitude, lat_long[[2]][1], lat_long[[2]][2])) %>%
      pull(in_range)
    num_unexp = length(subset_rows)
    print(paste(num_unexp, "values in not in lat/long range"))
  }
  
  filtered <- df[subset_rows, ]
  df <- df[!subset_rows,]
  if (return_type == "original"){
    return(df)
  } else if (return_type == "filtered"){
    return(filtered)
  }
}
```

```{r}
# Latitude Longitude
latlong = list(c(50, 70), c(-170, -140))
head(filter_df(survey_df, col, return_type = "original", lat_long = latlong))
```





# Plotting

  
## Distribution
```{r}
# conditions:
### "Temperature", "Salinity", "Oxygen", 
# species
### Phylum, Class, Subclass, Order, Suborder, Family, Subfamily, Genus, Subgenus, Species, Subspecies
# time
### IdentificationDate, ObservationDate, ObservationTime
# spatial
### DepthInMeters, MinimumDepthInMeters, MaximumDepthInMeters


filter_df(survey_df, col = "Temperature") %>% 
  ggplot(aes(x=Temperature)) + 
  geom_histogram()

survey_df = filter_df(survey_df, col = "Temperature") 
survey_df = filter_df(survey_df, col = "DepthInMeters") 
survey_df = filter_df(survey_df, col = "Phylum") 

# flip y axis for depth
survey_df %>% 
  ggplot(aes(x=Temperature, y=DepthInMeters, color=Phylum)) + 
  geom_point() + 
  scale_y_reverse()
```

  
  
## Geographic Location
```{r}
### Plot geographic location using ggplot ###
# option to color by species / depth / other condition
# conditions:
### "Temperature", "Salinity", "Oxygen", 
# species
### Phylum, Class, Subclass, Order, Suborder, Family, Subfamily, Genus, Subgenus, Species, Subspecies
# time
### IdentificationDate, ObservationDate, ObservationTime
# spatial
### DepthInMeters, MinimumDepthInMeters, MaximumDepthInMeters

set.seed(3)
survey_df = filter_df(survey_df, col="Phylum")
survey_sf <- survey_df %>% 
  st_as_sf(coords = c('Longitude', 'Latitude')) %>%
  st_set_crs(4326) # using 4326 for lat/lon decimal 


ggplot() +
  geom_sf(data = survey_sf, aes(color = Phylum), size = 3) 

```

```{r}
### Plots geographic location + background map ###
# Makes my computer lag 

library(sp)
library(leaflet)

coordinates(survey_df) <- ~Longitude + Latitude

# Plot the data using leaflet
leaflet(survey_df) %>%
  addTiles() %>%
  addMarkers()
```
  
