
#' Convert SBE19plus V2 hex files to cnv without SBE Data Processing
#'
#' This function decodes hexadecimal-formatted files that are generated by SeaTerm software then writes converted data to cnv files. Output files are similar to the output of SBE Data Processing software and can be read into R using oce::read.ctd().
#'
#' @param hex_path Path to a .hex file
#' @param output_path Path to the output file location for a .cnv file
#' @param xmlcon_file Optional. Path to config file. Must be provided if .hex file does not contain configuration file parameters.
#' @param sample_interval Sampling interval for scans; 0.25 for a typical SBE19plus V2 deployment.
#' @param output_channels Named vector of output channels and their names. Do not change from default unless additional channels of data are added.
#' @param output_sig_digits Significant digits after the decimal place for output channels. Do not change from default unless additional channels of data are added or sensor precision changes.
#' @export

hex_to_cnv <- function(hex_path,
                       output_path,
                       xmlcon_path = NULL,
                       sample_interval = 0.25,
                       output_channels = c("time_elapsed" = "timeS: Time, Elapsed [seconds]",
                                           "temperature" = "tv290C: Temperature [ITS-90, deg C]",
                                           "pressure" = "prdM: Pressure, Strain Gauge [db]",
                                           "conductivity" = "c0S/m: Conductivity [S/m]",
                                           "flag" = "flag:  0.000e+00"),
                       output_sig_digits = c("time_elapsed" = 3,
                                             "temperature" = 4,
                                             "pressure" = 3,
                                             "conductivity" = 6,
                                             "flag" = 1)) {

  # Split-up hex file into header and hex data
  lines_hex <- readLines(hex_path)
  end_header <- grep(pattern = "*END*", x = lines_hex)
  last_line <- length(lines_hex)
  lines_header <- lines_hex[1:(end_header-1)]

  # xmlcon variable names do not match hex file names and must be substituted
  if(!is.null(xmlcon_path)) {
    xmlcon_header <- readLines(xmlcon_path)

    init_var <- c("<A0>", "<A1>", "<A2>", "<A3>", "</A0>", "</A1>", "</A2>", "</A3>", "CPcor", "CTcor")
    repl_var <- c("<TA0>", "<TA1>", "<TA2>", "<TA3>", "</TA0>", "</TA1>", "</TA2>", "</TA3>", "CPCOR", "CTCOR")

    for(hh in 1:length(init_var)) {
      xmlcon_header <- gsub(x = xmlcon_header, pattern = init_var[hh], replacement = repl_var[hh])
    }

    lines_header <- c(lines_header, paste("#", xmlcon_header))

  }

  lines_data <- lines_hex[(end_header+1):(last_line-1)]

  # Remove invalid lines at the end
  lines_raw <- purrr::map(lines_data, .f = gapctd:::hex_line_to_raw)

  # Index of hex values for different channels
  cols <- tibble::tibble(
    start = c(1, 4, 7, 10),
    size = diff(c(start, 12)),
    big_endian = c(rep(TRUE, 4)),
    name = c("temperature_int", "conductivity_int", "pressure_int", "tvoltage_int")
  )

  # Add list of bytes to a tbl
  lines_tbl <- tibble::tibble(
    lines_hex = lines_data,
    lines_raw = lines_raw,
    scan = seq_along(lines_raw),
    pos = purrr::map(lines_raw, seq_along)
  )

  # Split list based on hex index
  values_int <- lines_tbl |>
    dplyr::select(scan, lines_raw) |>
    tidyr::unnest(lines_raw) |>
    dplyr::group_by(scan) |>
    dplyr::summarise(gapctd:::hex_extract_raw_uint_tbl(lines_raw, cols = cols))


  # Retrieve calibration coefficients from header

  cal_par_names <- c("TA0", "TA1", "TA2", "TA3", "TOFFSET", "G", "H", "I", "J", "CPCOR", "CTCOR", "CSLOPE", "PA0", "PA1", "PA2", "PTEMPA0", "PTEMPA1", "PTEMPA2", "PTCA0", "PTCA1", "PTCA2", "PTCB0", "PTCB1", "PTCB2", "POFFSET")

  cal_par_list <- list()

  for(ii in 1:length(cal_par_names)) {
    cal_par_list[[cal_par_names[ii]]] <- gapctd:::get_calibration_parameter(header = lines_header, cal_par = cal_par_names[ii])
  }

  # Check that necessary calibration parameters were in the hex file header if no .xmlcon file was provided
  if(is.null(xmlcon_path)) {
    if(any(is.na(cal_par_list))) {
      stop(paste0("hex_to_cnv: Calibration parameters ", paste(names(cal_par_list)[is.na(cal_par_list)], sep = ", "), "not found in ", hex_path))
    }
  }

  temperature  <- gapctd:::integer_to_temperature(
    temperature_integer = values_int$temperature_int,
    sig_figs = 4,
    a0 = cal_par_list[['TA0']],
    a1 = cal_par_list[['TA1']],
    a2 = cal_par_list[['TA2']],
    a3 = cal_par_list[['TA3']]
  )

  pressure <- gapctd:::integer_to_pressure(
    pressure_integer = values_int$pressure_int,
    temperature_integer = values_int$temperature_int,
    tvoltage_integer = values_int$tvoltage_int,
    ptempa0 = cal_par_list[['PTEMPA0']],
    ptempa1 = cal_par_list[['PTEMPA1']],
    ptempa2 = cal_par_list[['PTEMPA2']],
    ptca0 = cal_par_list[['PTCA0']],
    ptca1 = cal_par_list[['PTCA1']],
    ptca2 = cal_par_list[['PTCA2']],
    ptcb0 = cal_par_list[['PTCB0']],
    ptcb1 = cal_par_list[['PTCB1']],
    ptcb2 = cal_par_list[['PTCB2']],
    pa0 = cal_par_list[['PA0']],
    pa1 = cal_par_list[['PA1']],
    pa2 = cal_par_list[['PA2']],
    sig_figs = 3,
    convert_to_dbar = TRUE
  )


  conductivity <- gapctd:::integer_to_conductivity(
    conductivity_integer = values_int$conductivity_int,
    temperature = temperature,
    pressure = pressure,
    condg = cal_par_list[['G']],
    condh = cal_par_list[['H']],
    condi = cal_par_list[['I']],
    condj = cal_par_list[['J']],
    cpcor = cal_par_list[['CPCOR']],
    ctcor = cal_par_list[['CTCOR']],
    par0 = 256,
    par1 = 1000.0,
    sig_figs = 6
  )

  time_elapsed <- seq(0, (length(lines_data)-1)*sample_interval, sample_interval)
  flag <- rep(0, length(lines_data))

  cnv_dat <- list(
    data = data.frame(
      conductivity = conductivity,
      temperature = temperature,
      pressure = pressure,
      time_elapsed = time_elapsed,
      flag = flag
    ),
    hex_path = hex_path,
    sample_interval = sample_interval,
    cal_par_list = cal_par_list,
    header = lines_header,
    output_channels = output_channels,
    output_sig_digits = output_sig_digits
  )

  message("hex_to_cnv: Preparing to write data to cnv.")
  gapctd:::write_to_cnv(data_list = cnv_dat, output_path = output_path)

  return(cnv_dat)

}


